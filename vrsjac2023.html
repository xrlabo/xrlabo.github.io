<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

		<!-- Embed latest version of Babylon.js. -->
		<script src="https://cdn.babylonjs.com/babylon.js"></script>

        <!-- <script src="./Babylon.js/babylon.js"></script> -->

		<!-- Embed Babylon loader scripts for .gltf and other filetypes. -->
		<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

		<!-- Embed pep.js for consistent cross-browser pointer events. -->
		<script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>

        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

        <title>VRSJ AC 2023</title>
    </head>

    <body>
        <select id="robot-selection" onchange="robotonchange()" style="font-size: 20px; z-index: 100; position: absolute; left: 0; top: 0;">
            <option>Segway</option>
            <option>四足ロボット</option>
        </select>
        
        <div id="touchstart" style="width: 100%; height: 100%; text-align: center;">
            <input type="button" value="最初に画面をタッチしてください" onclick="onClicked();" style="font-size: 300%; position: absolute; left: 0; top: 0; width: 100%; height: 100%;">
        </div>
        
        <canvas id="renderCanvas" muted style="border: 3px solid gray; position: absolute; width: 100%; height: 100%; margin: auto; touch-action: none; z-index: 1;"></canvas>
        
        <div id="remote-videos">

            <video id="remoteVideo" muted controls style="border: 1px solid gray; width: 49.5%; float: left; display: none;"></video>

        </div>

        <script type="text/javascript" src="./sora2023.1.0.js"></script>
        <script type="text/javascript">
            let CLOSE_DATA_CHANNEL = false;
            let isTouched = false;
            let signaling_url = 'wss://u1.xr360d.net/signaling';
            // let signaling_url = 'wss://sora.ikeilabsora.0am.jp/signaling';
            let channel_id = 'segway-left';
            const debug = true;
            var sora = Sora.connection(signaling_url, debug);
            const options = {
                multistream : true,
                video : true,
                audio : true
            };
            var recvonly = sora.recvonly(channel_id, null, options);

            let mediaStream_id = null;

            function set_callback() {
                recvonly.on("track", (event) => {
                    console.log(event);
                    if (event.track.kind == "video") {
                        document.querySelector('#remoteVideo').srcObject = event.streams[0];
                        mediaStream_id = event.streams[0].id;
                    }
                });
            }

            function connect_clicked() {
                sora = Sora.connection(signaling_url, debug);
                recvonly = sora.recvonly(channel_id, null, options);
                set_callback();
                recvonly.connect();
            }

            connect_clicked()

            function onClicked() {
                if (mediaStream_id) {
                    document.querySelector('#remoteVideo').muted = false;
                    document.querySelector('#remoteVideo').volume = 1;
                    document.querySelector('#remoteVideo').play();
                    document.getElementById('touchstart').style = "display: none;";
                }
            }
            
            
            window.addEventListener('beforeunload', (e) => {
                e.preventDefault();
                recvonly.disconnect();
                console.log(e);
            });


            function robotonchange() {
                console.log('robotonchange');
                document.getElementById('touchstart').style = "width: 100%; height: 100%; text-align: center;";
                if (document.getElementById('robot-selection').value == 'Segway') {
                    channel_id = 'segway-left';
                    connect_clicked();
                }
                else {
                    channel_id = 'a1';
                    connect_clicked();
                }
            }


            /////////////////////////////////////////////////////////////////////////

            // canvas DOM 要素を取得する
			let canvas = document.getElementById('renderCanvas');

			// Initialize Babylon.js variables.
			const engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true
            });

            let camera;
            let cameraFovDegree = 60;

            let videoDome;
            let videoDecrimentalLoop_intervalID = null;
            let videoIncrimentalLoop_intervalID = null;
            let changeVideoFlag = false;


            //新しいシーンオブジェクトを作成する
            var scene = new BABYLON.Scene(engine);
            scene.ambientColor = new BABYLON.Color3(1, 1, 1);
            // scene.detachControl();

            //つねに原点を中心として回転するカメラを作成する
            camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", -Math.PI / 2, Math.PI / 2, 0, new BABYLON.Vector3(0, 0, 0), scene);
            // var camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), scene);
            // const camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 0, 0), scene)
            // const camera = new BABYLON.FreeCamera('MainCamera', new BABYLON.Vector3(0, 0, -2), scene);
            // カメラの向きを座標0地点にする
            // camera.setTarget(new BABYLON.Vector3(0, 0, 1));
            // カメラの視野角を 95 度に設定
            const cameraFovRadian = 70 * (Math.PI / 180);
            camera.fov = cameraFovRadian;
            console.log(camera);

            // Camera の操作を canvas 上で可能にする
            camera.attachControl(canvas, true);
            camera.panningAxis._x = 0; //水平移動無し。
            camera.panningAxis._y = 0; //垂直移動無し。
            if (camera.inputs.attached.keyboard) {
                camera.inputs.attached.keyboard.detachControl();
            }
            if (camera.inputs.attached.pointers) {
                camera.inputs.attached.pointers.multiTouchPanAndZoom = false;
                camera.inputs.attached.pointers.multiTouchPanning = false;
                camera.inputs.attached.pointers.pinchInwards = false;
                camera.inputs.attached.pointers.pinchZoom = false;
                camera.inputs.attached.pointers.angularSensibilityX = 3000;
                camera.inputs.attached.pointers.angularSensibilityY = 3000;
            }
            if (camera.inputs.attached.mousewheel) {
                camera.inputs.attached.mousewheel.detachControl();
            }
            scene.onPointerObservable.add(e => {
                cameraFovDegree += e.event.wheelDelta * 2**(-5);
                camera.fov = cameraFovDegree * (Math.PI / 180);
            }, BABYLON.PointerEventTypes.POINTERWHEEL);
            if (camera.inputs.attached.gamepad) {
                camera.inputs.attached.gamepad.detachControl();
            }

            console.log(camera);


            videoDome = new BABYLON.VideoDome(
                'VideoDome',
                document.getElementById('remoteVideo'),
                {
                    resolution: 64,
                    // clickToPlay: true,
                    autoPlay: true,
                    // size: 100
                    // useDirectMapping: false
                },
                scene
            );
            videoDome.setAbsolutePosition(new BABYLON.Vector3(0, 0, 0));
            videoDome.setDirection(new BABYLON.Vector3(0, 0, 0));

            let distance_past = 0, distance_current = 0;


            scene.registerBeforeRender(function () {
                if (camera.inputs.attached.pointers) {
                    if (camera.inputs.attached.pointers._pointA && camera.inputs.attached.pointers._pointB)
                    distance_current = (camera.inputs.attached.pointers._pointA.x - camera.inputs.attached.pointers._pointB.x)**2 + (camera.inputs.attached.pointers._pointA.y - camera.inputs.attached.pointers._pointB.y)**2;
                    if (distance_current > distance_past) {
                        cameraFovDegree = cameraFovDegree - 1;
                    }
                    if (distance_current < distance_past) {
                        cameraFovDegree = cameraFovDegree + 1;
                    }
                    distance_past = distance_current;
                    if (cameraFovDegree < 0) {
                        cameraFovDegree = 1;
                    }
                    if (cameraFovDegree > 180) {
                        cameraFovDegree = 179;
                    }
                    camera.fov = cameraFovDegree * (Math.PI / 180);
                }
            });


            // Create a default environment for the scene.
            var environment = scene.createDefaultEnvironment();
            // environment.ground.parent.position.y = 0;
            // environment.ground.position.y = 0

            engine.runRenderLoop(() => {
                scene.render();
            });
            // engine.runRenderLoop(function () {
			// 	scene.render();
			// });


			// Handle browser resize.
			window.addEventListener('resize', function () {
				engine.resize();
			});

    </script>
  </body>
</html>
